<!DOCTYPE html>
<html>
<head>
  <title>Annotated bibliography</title>
  <link href='../css/style.css' rel='stylesheet'>
  <meta name=viewport content="width=device-width, initial-scale=1">
</head>

<body>
  <div id=header>
    <a href="../">Annotated bibliography</a>
  </div>
  <div id="container">
<h1 id="review-of-gridding-method">Review of gridding method</h1>
<p>This is a review of the findings of O&#8217;Sullivan, 1985 and Jackson et al., 1991. These papers deal with the gridding method and its specific application to tomography. Also, the sinc function is shown to be the ideal interpolation kernel in Fourier domain.</p>
<h2 id="gridding-method">Gridding method</h2>
<p>We consider a 2D function in real space <span class="math inline">\(m(x,y)\)</span> whose Fourier transform <span class="math inline">\(M(u,v)\)</span> is given by <span class="math display">\[M(u,v) = \int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} m(x,y) e^{2\pi i (ux+vy)} dx dy.\]</span> In the tomography case, <span class="math inline">\(M(u,v)\)</span> is the Fourier transform of the image we want to reconstruct.</p>
<p>We also define a sampling function <span class="math inline">\(S(u,v)\)</span> in Fourier space, which is given by <span class="math display">\[S(u,v) = \sum_{j=i}^{k} \delta(u-u_j, v-v_j).\]</span> The 2D delta function in the equation above <em>samples</em> a function at points <span class="math inline">\((u_j, v_j)\)</span>, which form any grid (i.e.&#160;not necessarily Cartesian) in Fourier space. If we multiply this function to <span class="math inline">\(M(u,v)\)</span>, we get a sampled Fourier transform <span class="math display">\[M_S(u,v) = M(u,v) \cdot S(u,v).\]</span> The fist step of the gridding method is to convolve the sampled Fourier transform with a suitable kernel <span class="math inline">\(C(u,v)\)</span>: <span class="math display">\[M_{SC}(u,v) = (M(u,v) \cdot S(u,v)) \ast C(u,v),\]</span> where the subscripts in <span class="math inline">\(M_{SC}(u,v)\)</span> denote the operations sampling and convolution, respectively.</p>
<p>Next, the convolution shown above is sampled at Cartesian points <span class="math display">\[M_{SCS}(u,v) = \{(M(u,v) \cdot S(u,v)) \ast C(u,v)\} \cdot \Sha(u,v),\]</span> where <span class="math inline">\(\Sha(u,v)\)</span> denotes the Shah or comb function <span class="math display">\[\Sha(u,v) = \sum_{k} \sum_{j} \delta(u-k,v-j),\]</span> which samples points <span class="math inline">\((k,j)\)</span> that are equally spaced.</p>
<p>The reconstructed image <span class="math inline">\(m_{SCS}(x,y)\)</span> is given by the 2D inverse Fourier transform of <span class="math inline">\(M_{SCS}(u,v)\)</span>. Therefore, <span class="math display">\[m_{SCS}(x,y) = \{(m(x,y) \ast s(x,y)) \cdot c(x,y)\} \ast \Sha(x,y)\]</span></p>
<p>If the Fourier transform <span class="math inline">\(M(u,v)\)</span> is not sufficiently sampled by <span class="math inline">\(S(u,v)\)</span>, we cannot correct the aliasing of <span class="math inline">\(m(x,y)\)</span> via post-processing. However, we can add an additional correction for non-uniform sampling in Fourier space. For this, we consider an area density function given by <span class="math display">\[\rho(u,v) = S(u,v) \ast C(u,v).\]</span> Areas that are oversampled have a large area density while those that are undersampled have a small area density. Including this contribution in (5), we get a sampled and weighted function <span class="math display">\[M_{SWCS}(u,v) = \{\Bigg\{\Bigg(M(u,v) \cdot \frac{S(u,v)}{S(u,v) \ast C(u,v)}\Bigg) \ast C(u,v)\Bigg\}\} \cdot \Sha(u,v)\]</span> and its corresponding inverse Fourier transform <span class="math display">\[m_{SWCS}(x,y) =  \{(m(x,y) \ast (s(x,y) \ast^{-1} (s(x,y) \cdot c(x,y)))) \cdot c(x,y)\} \ast \Sha(x,y),\]</span> where <span class="math inline">\(\ast^{-1}\)</span> denotes deconvolution.</p>
<p>The question that presents itself at this stage is how to choose a kernel <span class="math inline">\(C(u,v)\)</span>. This is discussed in the following section.</p>
<h2 id="ideal-interpolation">Ideal interpolation</h2>
<p>We note that for an ideal interpolation, the inverse Fourier transform of our sampled, weighted and convolved function should be equal to the objective function at the sampled points. That is, <span class="math display">\[\Bigg(m_{SWC}(x,y)\Bigg)_S = \Bigg(m(x,y)\Bigg)_S.\]</span> Thus, what we want is to be able to recover a <em>continuous</em> function <span class="math inline">\(m(x,y)\)</span> from the <em>discrete sequence</em> of values at the sampled points by doing a convolution. Suppose that our Fourier grid sampling is done by a function of the form <span class="math inline">\(\Sha(u/u_0,v/v_0)\)</span>, such that the grid spacing in Fourier domain is given by <span class="math inline">\((1/u_0, 1/v_0)\)</span>. The inverse Fourier transform of this function is also a comb function and has the form <span class="math display">\[\Sha(x,y) = u_0 v_0 \Sha(xu_0, yv_0).\]</span> The sampled Fourier transform of our function is given by <span class="math display">\[M_{S}(u,v) = M(u,v) \cdot \Sha(u/u_0, v/v_0).\]</span> Its inverse Fourier transform is given by <span class="math display">\[\begin{aligned}
m_{S}(x,y) &amp;= m(x,y) \ast u_0v_0\Sha(xu_0, yv_0)\\
&amp;= m(x,y) \ast u_0v_0\sum_j \sum_k \delta(xu_0-j, yv_0-k)\\
&amp;=\sum_j \sum_k m\Big(x - \frac{k}{u_0}, y - \frac{j}{v_0}\Big).\end{aligned}\]</span> Additional weights can be added as constants multiplied to the sampling function. Here, we consider all weights to be equal to 1.</p>
<p>The function we want to reconstruct, <span class="math inline">\(m(x,y)\)</span>, has compact support. We define its support such that <span class="math inline">\(m(x,y) = 0\)</span> for <span class="math inline">\(x&gt;|x_0|\)</span> or <span class="math inline">\(y&gt;|y_0|\)</span>. We make use of the Whittaker-Shannon interpolation formula, which is a method to reconstruct a continuous time, bandlimited function from a sequence of real numbers. Given <span class="math inline">\(x(n) = x(nT)\)</span>, a sequence of real numbers with sampling period <span class="math inline">\(T\)</span>, the formula states that <span class="math display">\[x(t) = \sum_n x(n) \text{ sinc}\Bigg( \frac{t-nT}{T}\Bigg)\]</span> is a perfect reconstruction of the original function <span class="math inline">\(x(t)\)</span> if the bandlimit of the function, <span class="math inline">\(B\)</span>, is less than the Nyquist frequency, <span class="math inline">\(\frac{1}{2T}\)</span>. The reconstruction is equivalently given by <span class="math display">\[x(t) = \Bigg(\sum_n x(n) \cdot \delta(t-nT)\Bigg) \ast \text{ sinc}\Bigg( \frac{t}{T}\Bigg).\]</span> The function we want to reconstruct, <span class="math inline">\(m(x,y)\)</span>, has compact support in real space and its limits are given by <span class="math inline">\((x \leq x_0, y \leq y_0)\)</span>. Therefore, we can reconstruct it perfectly by multiplying its sampled Fourier transform with a sinc function, as shown in (17) and (18). To avoid aliasing, the sampling period in Fourier domain must obey the following <span class="math display">\[\begin{aligned}
\frac{1}{2u_0} &gt; x_0 \\
\frac{1}{2v_0} &gt; y_0\end{aligned}\]</span> Following (18), we have <span class="math display">\[M_{SC}(u,v) =\Bigg( \frac{1}{u_0v_0} \sum_k \sum_j M(u,v) \cdot \delta(u-ku_0, v-jv_0)\Bigg) \ast \text{sinc}\Bigg(\frac{u}{u_0}\Bigg)\text{sinc}\Bigg(\frac{v}{v_0}\Bigg),\]</span> where the term inside the first parentheses is <span class="math inline">\(M_{S}(u,v)\)</span>. Thus, we get a form for the kernel <span class="math inline">\(C(u,v)\)</span> in Fourier space: <span class="math display">\[C(u,v) = \frac{1}{u_0v_0}\text{sinc}\Bigg(\frac{u}{u_0}\Bigg)\text{sinc}\Bigg(\frac{v}{v_0}\Bigg).\]</span> Taking <span class="math inline">\(x_1 = 1/2u_0\)</span> and <span class="math inline">\(y_1 = 1/2v_0\)</span>, we can rewrite this as <span class="math display">\[C(u,v) = 4x_1 y_1 \text{sinc}(2x_1 u) \text{sinc}(2y_1 v).\]</span> <span class="math inline">\(M_{SC}(u,v)\)</span> is a perfect reconstruction of the continuous function <span class="math inline">\(M(u,v)\)</span> if <span class="math display">\[\begin{aligned}
x_0 &lt; x_1 \\
y_0 &lt; y_1.\end{aligned}\]</span> In real space, the sinc function in (23) is an ideal brick-wall low pass filter <span class="math inline">\(c(x,y)\)</span>, such that <span class="math display">\[\begin{aligned}
c(x,y) &amp;= 1, |x| \leq x_1 \text{ \&amp; } |y| \leq y_1 \\
&amp;= 0, \text{otherwise}.\end{aligned}\]</span> Then, <span class="math display">\[m_{SC}(x,y) = m_{S}(x,y) \cdot c(x,y) = m(x,y)\]</span> provided that <span class="math display">\[\begin{aligned}
x_0 \leq x_1 &lt; \frac{1}{u_0} - x_0 \\
y_0 \leq y_1 &lt; \frac{1}{v_0} - y_0\end{aligned}\]</span> The interpolation is completed by resampling the continuous function onto a grid (in our case, Cartesian) with spacing <span class="math inline">\((u_1, v_1)\)</span> <span class="math display">\[m_{SCS}(x,y)=\sum_j \sum_k m_{SC}\Big(x - \frac{k}{u_1}, y - \frac{j}{v_1}\Big),\]</span> provided <span class="math display">\[\begin{aligned}
x_0 &lt; \frac{1}{2u_1}\\
y_0 &lt; \frac{1}{2v_1}.\end{aligned}\]</span></p>
<p>Thus, <em>exact</em> interpolation to the Cartesian grid is possible. Note that in the case of the sinc kernel, the contribution of the kernel does not have to be removed after the inverse Fourier transform (a process known as deapodisation) because this kernel is chosen such that the sampled Fourier transform is <em>exactly equal</em> to the Fourier transform of the objective function on the Cartesian grid.</p>
<h2 id="finite-kernel">Finite kernel</h2>
<p>The sinc kernel has infinite extent and therefore convolution with the sinc kernel is computationally infeasible. Now, we consider the case that the kernel <span class="math inline">\(C(u,v)\)</span> has finite extent, which implies that its inverse Fourier transform <span class="math inline">\(c(x,y)\)</span> no longer has compact support. We also relax the condition that <span class="math inline">\(m(x,y)\)</span> has compact support (because of the finite sampling of <span class="math inline">\(M_S(u,v)\)</span> due to measurement). Thus, the function <span class="math display">\[m_{SC}(x,y) = m_S(x,y) \cdot c(x,y)\]</span> is of infinite extent and we take into account only a truncated version of this function for <span class="math inline">\(|x|&lt;x_1, |y|&lt;y_1\)</span>. In general, the sampling of this function <span class="math display">\[m_{SCS}(x,y) = \sum_j \sum_k m_{SC}\Bigg(x - \frac{k}{u_1}, y - \frac{j}{v_1} \Bigg)\]</span> is not an accurate representation of <span class="math inline">\(m_{SC}(x,y)\)</span> and is affected by aliasing errors. In general, the gridding method for functions of non-compact support does not correspond to an exact interpolation and the values of the sampled function do not match the values of the objective function exactly, even at the measurement points. However, the objective function can be estimated by deapodisation: <span class="math display">\[m_e(x,y) = \frac{m_{SCS}(x,y)}{c(x,y)}, |x|&lt;x_1 \text{ \&amp; } |y|&lt;y_1,\]</span> where <span class="math inline">\(m_e(x,y)\)</span> is the estimate of the objective function <span class="math inline">\(m(x,y)\)</span>. The central point (<span class="math inline">\(k=0, j=0\)</span>) is computed exactly by deapodisation. At the other points, the error in the estimated function is given by <span class="math display">\[\begin{aligned}
m_e(x,y) - m_{S}(x,y) &amp;= \frac{m_{SCS}(x,y)}{c(x,y)} - m_{S}(x,y) \\
&amp;= \frac{1}{c(x,y)}\sum_j \sum_k m_{SC}\Bigg(x - \frac{k}{u_1}, y - \frac{j}{v_1} \Bigg) - m_S(x,y)\\
&amp;= \frac{1}{c(x,y)}\sum_j \sum_k m_{S}\Bigg(x - \frac{k}{u_1}, y - \frac{j}{v_1} \Bigg) \cdot c\Bigg( x - \frac{k}{u_1}, y - \frac{j}{v_1}\Bigg) - m_S(x,y) \\
&amp;= \frac{1}{c(x,y)}\sum_{j\neq0} \sum_{k\neq0} m_{S}\Bigg(x - \frac{k}{u_1}, y - \frac{j}{v_1} \Bigg) \cdot c\Bigg( x - \frac{k}{u_1}, y - \frac{j}{v_1}\Bigg)\end{aligned}\]</span></p>
<p>The accuracy of the gridding method depends on the rate of decay of <span class="math inline">\(c(x,y)\)</span> outside the region of interest (<span class="math inline">\(|x| \leq x_1, |y| \leq y_1\)</span>). An optimality criterion for the selection of a suitable kernel was proposed by Schwab in a 1983 paper: <span class="math display">\[R  = \frac{\displaystyle \iint_A |c(x,y)|^2 w(x,y) dx dy}{\displaystyle \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} |c(x,y)|^2 w(x,y) dx dy},\]</span> where <span class="math inline">\(A\)</span> is the region in which <span class="math inline">\(c(x,y)\)</span> should be concentrated and <span class="math inline">\(w(x,y)\)</span> are weight functions. Schwab also showed that <span class="math inline">\(R\)</span> is maximised by zero-order prolate spheroidal wavefunctions, which can be approximated by Kaiser-Bessel window functions.</p>
<h1 id="application-of-regridding-method-to-gridrec">Application of regridding method to Gridrec</h1>
<p>The gridding method has been used in tomography to perform direct Fourier inversion from a non-uniformly sampled Fourier domain. The backprojector in such a method corresponds exactly to performing a gridding operation, while the forward projector is a composition of the same operations &#8220;in reverse&#8221;.</p>
<h2 id="formulation-of-the-backprojector">Formulation of the backprojector</h2>
<p>This is a review of the formulation of the gridding backprojector introduced in Arcadu et al., 2016. Backprojection is done using a series of five operations:</p>
<ol type="1">
<li><p>1D Fourier transform of projections: <span class="math inline">\(\hat{P_\theta}(\omega) = \mathcal{F}_{1D}\{P_\theta(t)\}\)</span></p></li>
<li><p>Ramp filtering of projections: <span class="math inline">\(\hat{P_\theta}^{(f)}(\omega) = |\omega| \cdot \hat{P_\theta}(\omega)\)</span></p></li>
<li><p>Convolution with interpolation kernel: <span class="math inline">\(\hat{f}^{(m)} = \hat{c} \ast \hat{P_\theta}^{(f)}(\omega)\)</span></p></li>
<li><p>2D inverse Fourier transform of the image: <span class="math inline">\(f^{(m)} = \mathcal{F}^{-1}_{2D}\{\hat{f}^{(m)}\}\)</span></p></li>
<li><p>Removal of the interpolation kernel (deapodisation): <span class="math inline">\(f = f^m/c\)</span></p></li>
</ol>
<p>We can write down the backprojection operation using the sampling and convolution functions introduced in the previous sections (cf eq.&#160;10): <span class="math display">\[f_{SWCSD}(x,y) =  \Bigg(\Big\{\big(f(x,y) \ast (s(x,y) \ast^{-1} \rho(x,y))\big) \cdot c(x,y)\Big\} \ast \Sha(x,y)\Bigg) \cdot \frac{\Pi(x,y)}{c(x,y)},\]</span> where <span class="math inline">\(\Pi(x,y)\)</span> is the boxcar function, <span class="math inline">\(\Pi(x,y) = 1; |x|&lt;1/2,|y|&lt;1/2\)</span>, used to crop the reconstruction to the region of interest and <span class="math inline">\(\rho(x,y) = s(x,y) \cdot c(x,y)\)</span> is the inverse Fourier transform of the area density function introduced in (8).</p>
<p>Forward projection is done by applying the operations in reverse. However, ramp filtering, which is done in backprojection to compensate for the non-uniform sampling in the Fourier domain, is not performed. Therefore, we can write down forward projection as: <span class="math display">\[\begin{aligned}
f_{DSCS}(x,y) &amp;= \Bigg(\Big\{\big(f(x,y) / c(x,y)\big) \cdot \Sha(x,y)\Big\} \cdot c(x,y)\Bigg) \ast s(x,y) \\
&amp;= \Bigg(\Big\{\big(f(x,y) \cdot \Sha(x,y)\big) / c(x,y) \Big\} \cdot c(x,y)\Bigg) \ast s(x,y) \\
&amp;= \Bigg(f(x,y) \cdot \Sha(x,y) \Bigg) \ast s(x,y).\end{aligned}\]</span> We see from the equations above, that forward projection can be seen as a sampling of the function by a Shah function <span class="math inline">\(\Sha(x,y)\)</span>, followed by resampling onto a different (possibly non-uniform) grid in Fourier space.</p>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  </div>

  <script type="text/javascript" src="../js/mathjax_config.js"></script>
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-90310997-2', 'auto');
		ga('send', 'pageview');
	</script>
</body>
</html>
